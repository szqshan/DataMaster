# 数据库工具问题分析与改进方案

## 问题总结

根据用户反馈，在使用数据分析工具读取股票数据过程中遇到了以下问题：

### 1. 数据库表信息查询问题
**问题描述**：
- 使用 `get_data_info` 工具查询表信息时出现语法错误
- 错误信息：`near "-": syntax error`
- 影响：无法直接通过工具获取数据库结构信息

**根本原因**：
在 `get_data_info` 函数中，直接使用字符串拼接构建SQL查询：
```python
cursor = conn.execute(f"SELECT COUNT(*) FROM {table}")
cursor = conn.execute(f"PRAGMA table_info({table_name})")
```
当表名包含特殊字符（如连字符 `-`）时，会导致SQL语法错误。

### 2. SQL语句格式限制
**问题描述**：
- 执行带分号的SQL语句时报错
- 错误信息：`You can only execute one statement at a time`
- 解决方案：去掉SQL语句末尾的分号

**根本原因**：
SQLite的 `execute()` 方法只能执行单条语句，不支持多语句执行。

### 3. DataFrame序列化问题
**问题描述**：
- 尝试以DataFrame格式获取数据时失败
- 错误信息：`Object of type DataFrame is not JSON serializable`
- 影响：无法直接获取DataFrame格式的数据进行分析

**根本原因**：
DataFrame对象无法直接序列化为JSON格式，需要转换为可序列化的数据结构。

### 4. API配置问题
**问题描述**：
- 初始API配置测试失败
- 错误信息：端点 `global_quote` 缺少path配置 和 API Key认证缺少api_key配置
- 解决方案：重新配置API，调整配置格式

**根本原因**：
API配置验证机制不够完善，缺少详细的配置格式说明和验证。

## 改进方案

### 1. 修复数据库表名特殊字符问题

#### 问题分析
当前代码中存在多处直接使用字符串拼接构建SQL查询的地方：
- `get_data_info` 函数中的表统计查询
- `_calculate_basic_stats` 函数中的统计计算
- 其他数据处理函数中的表名引用

#### 解决方案
1. **使用SQL标识符引号**：对所有表名和列名使用双引号包围
2. **参数化查询**：在可能的情况下使用参数化查询
3. **统一的表名处理函数**：创建专门的函数处理表名转义

#### 具体修改
```python
def _escape_identifier(identifier: str) -> str:
    """转义SQL标识符（表名、列名等）"""
    # 使用双引号包围标识符，并转义内部的双引号
    return f'"{identifier.replace('"', '""')}"'

def _safe_table_query(table_name: str, query_template: str) -> str:
    """安全地构建包含表名的查询"""
    escaped_table = _escape_identifier(table_name)
    return query_template.format(table=escaped_table)
```

### 2. 增强SQL执行器功能

#### 改进点
1. **多语句支持**：提供批量执行多条SQL语句的功能
2. **更清晰的错误提示**：提供具体的错误原因和解决建议
3. **SQL语句预处理**：自动处理常见的格式问题

#### 具体实现
```python
@mcp.tool()
def execute_sql_batch(
    queries: list,
    params: dict = None,
    limit: int = 1000,
    continue_on_error: bool = False
) -> str:
    """批量SQL执行工具"""
    # 实现批量执行逻辑
    pass

def _preprocess_sql(query: str) -> str:
    """预处理SQL语句"""
    # 移除末尾分号
    query = query.strip().rstrip(';')
    return query
```

### 3. 优化数据格式支持

#### DataFrame序列化改进
1. **多种输出格式**：支持JSON、CSV、Excel等多种格式
2. **智能序列化**：自动处理特殊数据类型
3. **分页支持**：对大数据集提供分页功能

#### 具体实现
```python
def _serialize_dataframe(df: pd.DataFrame, format_type: str = "json") -> dict:
    """序列化DataFrame为可传输格式"""
    if format_type == "json":
        return {
            "columns": df.columns.tolist(),
            "data": df.to_dict('records'),
            "shape": df.shape,
            "dtypes": df.dtypes.astype(str).to_dict()
        }
    elif format_type == "summary":
        return {
            "shape": df.shape,
            "columns": df.columns.tolist(),
            "dtypes": df.dtypes.astype(str).to_dict(),
            "head": df.head().to_dict('records'),
            "describe": df.describe().to_dict() if df.select_dtypes(include=[np.number]).shape[1] > 0 else None
        }
```

### 4. 完善API配置验证

#### 改进点
1. **配置模板**：提供标准的API配置模板
2. **详细验证**：检查所有必需的配置项
3. **友好提示**：提供具体的配置错误信息和修复建议

#### 具体实现
```python
def validate_api_config(config: dict) -> tuple[bool, str]:
    """验证API配置"""
    required_fields = ['base_url', 'endpoints']
    missing_fields = []
    
    for field in required_fields:
        if field not in config:
            missing_fields.append(field)
    
    if missing_fields:
        return False, f"缺少必需配置项: {', '.join(missing_fields)}"
    
    # 验证endpoints配置
    for endpoint_name, endpoint_config in config['endpoints'].items():
        if 'path' not in endpoint_config:
            return False, f"端点 '{endpoint_name}' 缺少 'path' 配置"
        
        if endpoint_config.get('auth', {}).get('type') == 'api_key':
            if 'api_key' not in endpoint_config['auth']:
                return False, f"端点 '{endpoint_name}' 的API Key认证缺少 'api_key' 配置"
    
    return True, "配置验证通过"
```

### 5. 增强错误处理机制

#### 改进点
1. **统一错误格式**：标准化所有工具的错误返回格式
2. **错误分类**：按错误类型提供不同的处理建议
3. **调试信息**：在开发模式下提供详细的调试信息

#### 具体实现
```python
class ToolError(Exception):
    """工具错误基类"""
    def __init__(self, message: str, error_type: str = "unknown", suggestions: list = None):
        self.message = message
        self.error_type = error_type
        self.suggestions = suggestions or []
        super().__init__(message)

def format_error_response(error: Exception, context: str = "") -> dict:
    """格式化错误响应"""
    if isinstance(error, ToolError):
        return {
            "status": "error",
            "message": error.message,
            "error_type": error.error_type,
            "suggestions": error.suggestions,
            "context": context
        }
    else:
        return {
            "status": "error",
            "message": str(error),
            "error_type": type(error).__name__,
            "context": context
        }
```

## 实施计划

### 第一阶段：核心问题修复
1. 修复 `get_data_info` 函数的表名特殊字符问题
2. 改进 `execute_sql` 函数的错误处理
3. 添加DataFrame序列化支持

### 第二阶段：功能增强
1. 实现批量SQL执行功能
2. 完善API配置验证机制
3. 统一错误处理格式

### 第三阶段：用户体验优化
1. 添加配置模板和示例
2. 改进错误提示和建议
3. 增加调试和日志功能

## 预期效果

1. **解决表名特殊字符问题**：支持包含连字符、中文等特殊字符的表名
2. **提升SQL执行灵活性**：支持多语句执行和更好的错误处理
3. **改善数据格式支持**：提供多种数据输出格式，解决序列化问题
4. **完善API配置**：提供清晰的配置指南和验证机制
5. **增强用户体验**：提供友好的错误信息和解决建议

通过这些改进，将显著提升数据分析工具的稳定性和易用性，为用户提供更好的数据处理体验。